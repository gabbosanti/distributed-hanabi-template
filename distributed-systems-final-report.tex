\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{cleveref} % this must be the last package to be loaded

\newcommand{\emailaddr}[1]{\href{mailto:#1}{\texttt{#1}}}

\title{\LARGE
    Distributed Hanabi
}

\subtitle{Final Report for the Distributed Systems Course 2025-2026}

\author{
    Blagoja Savevski \\ \emailaddr{blagoja.savevski@studio.unibo.it}
    \and
    Gabriele Santi \\ \emailaddr{gabriele.santi@studio.unibo.it}
    \and
    Pengyue Xu \\ \emailaddr{pengyue.xu@studio.unibo.it}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Hanabi is a cooperative multiplayer card game for 2-5 players where players score by guessing their own hidden cards based on hints given by other players. This project aims to implement a working version of the game that manages the shared state consistently and reliably, while being able to tolerate disconnects from a client or the server. 
\end{abstract}

\section{Concept}\label{concept}

{\scriptsize Here you should explain:
  \begin{itemize}
    \item \emph{what} is the software doing?
    \item \emph{where} are the users?
    \item \emph{when} and \emph{how frequently} do they interact with the system?
    \item \emph{how} do they \emph{interact} with the system? which \emph{devices} are they using?
  
    \item does the system need to \emph{store} user's \textbf{data}? 
    \emph{which}? \emph{where}?
    \item most likely, there will be \emph{multiple} \textbf{roles}
    
  \end{itemize} 
}
\subsection{Context}
The software implements the game Hanabi, a 3-5 player cooperative board game, where players attempt to build the greatest "pyrotechnic show" by ordering each other's cards. Each player starts with 4-5 cards depending on the player count from a 50 card deck. The goal is to order the cards by number (1-5) and by color (red,yellow,green,blue,white). Information for your own cards must only be acquired through the strict communication methods the action systems permits. A successful game ends with 5 different colored decks in increasing order. 
The users can run the program from different machines on the same network. 
Each turn, one user does one of the allowed actions, then the updated game state is shared to all the users. 
Each player can:
    \begin{itemize}
        \item \emph{Give a hint} to another player and spend one of 8 hint tokens in total. The hint can give information about either the color or the number of a subset of the other player's cards. 
        \item \emph{Play a card} and attempt to place it in order in one of the colored decks. If the card turns out to be in the wrong color, or lesser or equal to the topmost of that color deck, the move is considered unsuccessful and one of 3 life tokens is spent. Then he draws a card in the place of the played one. 
        \item \emph{Discard} one card from his hand and return one of the already spent tokens to the pool. The player must end each turn with the same amount of cards and so a new card is drawn. 
    \end{itemize}
    The system needs to store basic player information - at least an unique ID, in order to conduct orderly match creation and orchestration. In addition, additional information about the player's previous success in game can provide an ordering system for better matchmaking. Afterwards, the system is expanded to store previous games per game ID so that they can be restarted. 

\subsection{Use Case description}
The aim of this project is to design and implement a distributed version of the game Hanabi.
It consist on a web-based application, where players can connect to a server and play togheter directly from their browsers.
A group between 2 and 5 players from distinct machines can play togheter and form a team, by starting the client and connecting to the central server.
The server is responsible for creating a new game and assigning a unique game ID, enabling persistent storage of its state and potential recovery in case of system restart.
Playes visualize the game shared state on their clients and, on each turn, send command to the server. Each command is validated by the server, according to Hanabi rules, then updates the game state accordingly and notifies all players of the new state.

\subsection{Reasons for distribution}

{\scriptsize Why is distribution needed?
  %
  \begin{itemize}
    \item geographically distributed environments?
    \item computation speedup?
    \item resource sharing?
    \item fault tolerance?
    \item other reasons?
  \end{itemize}
}

The distributed nature of the system is inherent to the problem domain. The game is designed to be played by multiple users connecting from different machines, potentially located in geographically separated environments. Therefore, a centralized single-machine solution would not satisfy the project requirements.

From a systems perspective, distribution is required for several reasons:

\begin{itemize}

    \item \textbf{Geographically distributed environment:} 
    Players connect from different devices over a network that may be unreliable, lossy, or subject to delays. The system must therefore tolerate message latency, disconnections, and partial failures.

    \item \textbf{Resource sharing:} 
    The game state represents a shared resource accessed by multiple participants. Although gameplay is turn-based, the system must guarantee consistency of the replicated state and ensure that all clients observe the same authoritative version of the game.

    \item \textbf{Fault tolerance:} 
    To avoid interrupting active game sessions, the server component can be replicated. Through a consensus mechanism, a leader (master) node is elected to manage state transitions. In case of failure, another replica can be promoted, allowing the system to continue operating without losing persistent state.

    \item \textbf{Coordination and consistency:} 
    Even though only one player performs an action per turn, the distributed environment introduces challenges such as message ordering, duplicated requests, and possible race conditions during failures. The system must therefore enforce a well-defined consistency model.

\end{itemize}
\section{Requirements Elicitation and Analysis}\label{requirements}

{\scriptsize
\begin{itemize}
  \item The requirements must explain \textbf{what} (not how) the software
  being produced should do.
  %
  \begin{itemize}
    \item you should not focus on the particular problems, but exclusively on
    what you want the application to do.
  \end{itemize}

  \item Requirements must be clearly identified, and possibly numbered

  \item Requirements are divided into:
  %
  \begin{itemize}
    \item \textbf{Functional}: some functionality the software should provide to the user

    \item \textbf{Non-functional}: requirements that do not directly concern behavioural aspects, such as consistency, availability, etc.
    \item \textbf{Implementation}: constrain the entire phase of system realization, 
    for instance by requiring the use of a specific programming language and/or a specific software tool
    %
    \begin{itemize}
      \item these constraints should be adequately justified by political / economic / administrative reasons\ldots{}
      \item \ldots{} otherwise, implementation choices should emerge \emph{as  a consequence of} design
    \end{itemize}
  \end{itemize}

  \item If there are domain-specific terms, these should be explained in a glossary
  
  \item Each requirement must have its own \textbf{acceptance criterion}
  %
  \begin{itemize}
    \item these will be important for the validation phase
  \end{itemize}
\end{itemize}
}
\subsection{Relevant Distributed System Features}
\label{ds-features}

Motivate which distributed system features are relevant for your project, and which are not.
%
\begin{itemize}
  \item transparency
  \begin{itemize}
    \item does your system need to hide distribution details from users or developers?
    \item is it important that failures, location, or replication are invisible?
    
    \item Transparency of replication/failure - hidden copies of the master may seamlessly take over in case of a failure. 
  \end{itemize}

  \item fault tolerance, dependability -- availability, reliability, integrity, maintainability, safety
  \begin{itemize}
    \item what happens if a component fails? is uninterrupted service required?
    \item is data loss or corruption unacceptable?
    Data loss/corruption is prevented on the transport level. 
    \item how quickly must the system recover from faults?
    The system needs to recover from fault in a time that ensures an acceptable level of availability to the users. 
  \end{itemize}

  \item scalability
  \begin{itemize}
    \item will the system need to handle increasing numbers of users, requests, or data?
    Yes. Multiple instances of game servers can get deployed and work in parallel. The scope for scalability is limited and so a simpler but less expandable deployment method will be used. The number of nodes that balance the demand on the system by creating and destroying server instances should grow proportionally to the total number of players, up to the level possible by the system's resources (memory,CPU).
    \item is it expected to grow over time?
    
  \end{itemize}

  \item security, trust
  \begin{itemize}
    \item is sensitive data being processed or stored?
    It is possible to expand the system to allow for user authentication and for the need to arise for safely storing passwords. 
    \item are there multiple user roles with different permissions?
    \item is authentication or authorization required?
    Authentication is required so that the system can conclude the user is precisely the one identified by the ID. 
  \end{itemize}

  \item resource sharing
  \begin{itemize}
    \item do multiple users or components need access to shared resources?
    \item is coordination or synchronization needed?
    Synchronization is done by broadcasting the shared game state at each game turn. Game state is persistent so that a game can be restarted synchronously after any issues arise. The events of the game have a natural total ordering so event order can always be reconstructed. 
  \end{itemize}

  % \item openness, interoperability, heterogeneity of components
  % \begin{itemize}
  %   \item Will your system interact with external systems or use components built with different technologies?
  %   \item Is standardization or compatibility important?
  % \end{itemize}

  % \item evolvability, maintainability
  % \begin{itemize}
  %   \item Will the system need to be updated or extended after deployment?
  %   \item Is long-term maintenance a concern?
  % \end{itemize}

  \item performance, concurrency, computation / communication efficiency, bandwidth
  \begin{itemize}
    \item Are there strict requirements on response time or throughput?
    \item Will many operations happen in parallel?
    The system will execute the called procedures on the different games concurrently. 
    \item Is network usage a concern?
    As the game state can be sent in reasonably sized JSON format messages, network issues are not expected to arise until extreme loads on the system. 
  \end{itemize}

%   \item economy, costs  
%   \begin{itemize}
%     \item Are there budget constraints for development, deployment, or operation?
%     \item Is minimizing resource usage important?
%   \end{itemize}
\end{itemize}

\section{Design}\label{design}

This chapter explains the strategies used to meet the requirements identified in the analysis. 
%
Ideally, the design should be the same, regardless of the technological choices made during the implementation phase.

\begin{quote}
You can re-arrange the sections as you prefer, but all the sections must be present in the end
\end{quote}

\noindent
\textbf{Important:} try to motivate your design choices in relation to the requirements and features identified 
in \cref{requirements} and \cref{ds-features}.

\subsection{Architecture}\label{architecture}

\begin{itemize}
  \item Which architectural style?
  %
  \begin{itemize}
    \item \emph{Client-server architecture}. In order to manage the state consistently, the server process singularly takes up the requests of the client processes and executes each update of the state. After each update, executed as a remote procedure call upon the GameState object, the new state is broadcasted to all the players. This enables for a separation between the application logic in the GameState object and the communicational logic in the Server object. \footnote{According to the popular board gaming website boardgamearena \cite{bgastudio}, C-S is the optimal choice compared to P2P for real time mass game orchestration.} 
    \item \emph{Request-Response Remote Procedure Calling} upon the remote object GameState. The server unmarshalls the client's request, calls a remote procedure with the relevant sent parameters and marshalls a response in the corresponding JSON format. The client is unaware that the the game is executed on another device (transparency of location). 
    % add more here 
  \end{itemize}
\end{itemize}

\subsection{Infrastructure}\label{infrastructure}

\begin{itemize}
  \item are there \emph{infrastructural components} that need to be introduced? \emph{how many}?
  %
  \begin{itemize}
    \item e.g.~\emph{clients}, \emph{servers}, \emph{load balancers},
    \emph{caches}, \emph{databases}, \emph{proxies}, \emph{firewalls},
    \emph{CDNs}, \emph{etc.}
  \end{itemize}

  \item how do components \emph{distribute} over the network? \emph{where}?
  %
  \begin{itemize}
    \item e.g.~do servers / brokers / databases / etc. sit on the same
    machine? on the same network? on the same datacenter? on the same
    continent?
  \end{itemize}

  \item how do components \emph{find} each other?
  %
  \begin{itemize}
    \item how to \emph{name} components?
    \item e.g.~DNS, \emph{service discovery}, \emph{load balancing},
    \emph{etc.}
  \end{itemize}
\end{itemize}

\begin{quote}
Component diagrams are welcome here
\end{quote}
\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{figures/почеток-архитектура.png}
    \caption{Caption}
    \label{fig:placeholder}
\end{figure}
\subsection{Modelling}\label{modelling}
% add objects and methods here 
\begin{itemize}
  \item which \textbf{domain entities} are there?
  %
  \begin{itemize}
    \item e.g.~\emph{users}, \emph{products}, \emph{orders}, \emph{etc.}
  \end{itemize}
  
  \item how do \emph{domain entities} \textbf{map to} \emph{infrastructural components}?
  %
  \begin{itemize}
    \item e.g.~state of a video game on central server, while inputs/representations on clients
    \item e.g.~where to store messages in an IM app? for how long?
  \end{itemize}

  \item which \textbf{domain events} are there?
  %
  \begin{itemize}
    \item e.g.~\emph{user registered}, \emph{product added to cart}, \emph{order placed}, \emph{etc.}
  \end{itemize}
  
  \item which sorts of \textbf{messages} are exchanged?
  %
  \begin{itemize}
    \item e.g.~\emph{commands}, \emph{events}, \emph{queries}, \emph{etc.}
  \end{itemize}

  \item what information does the \textbf{state} of the system comprehend
  %
  \begin{itemize}
    \item e.g.~\emph{users' data}, \emph{products' data}, \emph{orders' data}, \emph{etc.}
  \end{itemize}
\end{itemize}

\begin{quote}
Class diagram are welcome here
\end{quote}

\subsection{Interaction}\label{interaction}

\begin{itemize}
  \item how do components \emph{communicate}? \emph{when}? \emph{what}?
  \item \emph{which} \textbf{interaction patterns} do they enact?
\end{itemize}
%R-R as mentioned before? maybe put that here 
%sequence diagram on that 
\begin{quote}
Sequence diagrams are welcome here
\end{quote}

\subsection{Behaviour}\label{behaviour}

\begin{itemize}
  \item how does \emph{each} component \textbf{behave} individually (e.g.~in \emph{response} to \emph{events} or messages)?
  \begin{itemize}
    \item some components may be \emph{stateful}, others \emph{stateless}
  \end{itemize}

  \item which components are in charge of updating the \textbf{state} of the system? \emph{when}? \emph{how}?
\end{itemize}

\begin{quote}
State diagrams are welcome here
\end{quote}

\subsection{Data and Consistency Issues}\label{data-and-consistency-issues}

\begin{itemize}
  \item Is there any data that needs to be stored?
  % need to add persistent database of player ids to code for matchmaking
  \begin{itemize}
    \item \emph{what} data? \emph{where}? \emph{why}?
  \end{itemize}
  
  \item how should \emph{persistent data} be \textbf{stored}?
  Hash table sey-value store for O(1) insertions and reads, if ranked matchmaking needed (range queries) it can be b+ tree based. 
  % KV store ig player id to player info. 
  \begin{itemize}
    \item e.g.~relations, documents, key-value, graph, etc.
    \item why?
  \end{itemize}
  
  \item Which components perform queries on the database?
  %
  The matchmaker that spawns matches. 
  \begin{itemize}
    \item \emph{when}? \emph{which} queries? \emph{why}?
    Query for a number of players to create a lobby, if enough are online currently. 
    \item concurrent read? concurrent write? why?
    hmm ? ex writes online state for player when reading online players problem 
  \end{itemize}
  
  \item Is there any data that needs to be shared between components?
  % not really 
  \begin{itemize}
    \item \emph{why}? \emph{what} data?
  \end{itemize}
\end{itemize}

\subsection{Fault-Tolerance}\label{fault-tolerance}

\begin{itemize}
  \item Is there any form of data \textbf{replication} / federation / sharing?
  % data repl i think not. 
  
  \begin{itemize}
    \item \emph{why}? \emph{how} does it work?
  \end{itemize}
  
  \item Is there any \textbf{heart-beating}, \textbf{timeout}, \textbf{retry mechanism}?
  % we might need to implement 
  % currently client polls constantly. We can impl heartbeat so that server ends the game if client on turn not responding. 
  \begin{itemize}
    \item \emph{why}? \emph{among} which components? \emph{how} does it work?
  \end{itemize}
  
  \item Is there any form of \textbf{error handling}?
  %
  \begin{itemize}
    \item \emph{what} happens when a component fails? \emph{why}? \emph{how}?
  \end{itemize}
  When redis master server fails, a replica is promoted if consensus exists. If the master rejoins again, he is informed that he is demoted to a replica. 
\end{itemize}

\subsection{Availability}\label{availability}
Availability is permitted by a level of fault tolerance. 
%write more here 
\begin{itemize}
  \item Is there any \textbf{caching} mechanism?
    The client process saves a local copy of the last received state. When issues arise this copy can serve as a fallback so that availability is prioritized over consistency. 
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}
  
  \item Is there any form of \textbf{load balancing}?
  %
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}

  \item In case of \textbf{network partitioning}, how does the system behave?
  % rn i have them all on static ips. we need to think about this i think profesor would like. 
  \begin{itemize}
    \item \emph{why}? \emph{how}?
  \end{itemize}
\end{itemize}

\subsection{Security}\label{security}

\begin{itemize}
  \item Is there any form of \textbf{authentication}?
  % We can add this. Probably easy to do. Players must authenticate with password, maybe use schema from exercises profesor. validation in server 
  \begin{itemize}
    \item \emph{where}? \emph{why}?
  \end{itemize}

  \item Is there any form of \textbf{authorization}?
  % i dont think so 
  \begin{itemize}
    \item which sort of \emph{access control}?
    \item which sorts of users / \emph{roles}? which \emph{access rights}?
  \end{itemize}

  \item Are \textbf{cryptographic schemas} being used?
  % we could add this if in mood but idk if worth the effort 
  \begin{itemize}
    \item e.g.~token verification,
    \item e.g.~data encryption, etc.
  \end{itemize}
\end{itemize}

\section{Implementation}\label{implementation}

Please report here all the implementation (technology-dependent) choices you made while implementing your design.


\begin{itemize}
  \item which \textbf{network protocols} to use?
  %
  \begin{itemize}
    \item TCP,WebSockets,
  \end{itemize}
  
  \item how should \emph{in-transit data} be \textbf{represented}?
  %
  \begin{itemize}
    \item JSON dictionary
  \end{itemize}
  
  \item how should \emph{databases} be \textbf{queried}?
  %
  \begin{itemize}
    \item Queries by key. 
  \end{itemize}
  
  \item how should components be \emph{authenticated}?
  %
  \begin{itemize}
    \item OAuth perhaps
  \end{itemize}

\end{itemize}

\subsection{Technological details}\label{technological-details}

\begin{itemize}
  \item any particular \emph{framework} / \emph{technology} being exploited goes here
\end{itemize}

\section{Validation}\label{validation}
The application logic was tested out separately from the communication protocol implemented. End-to-end testing was done to ensure the complete system meets the specification. 
\subsection{Automatic Testing}\label{automatic-testing}

\begin{itemize}
  \item how were individual components \textbf{\emph{unit}-test}ed?
  The client and server nodes were tested in regards to all possible communication possibilities - connect, send, receive, timeout. The GameState object was unit tested in regards to the functioning of all the RPC's that can be called upon the object. 
  \item how was communication, interaction, and/or integration among components tested?
  Unit tests were done for the matchmaker to see if it properly instantiates and destroys matches. 
  Multiple server instances working concurrently were spawned to test out the system in a simulated production environment. 
  \item how to \textbf{\emph{end-to-end}-test} the system?
  %
  \begin{itemize}
    \item e.g.~production vs.~test environment
  \end{itemize}

  \item for each test specify:
  % dont know if going into this much detail makes sense at the moment 
  \begin{itemize}
    \item rationale of individual tests
    \item how were the test automated
    \item how to run them
    \item which requirement they are testing, if any
  \end{itemize}
\end{itemize}

\begin{quote}
recall that \emph{deployment} \textbf{automation} is commonly used to \emph{test} the system in \emph{production-like} environment
% we can try automated deployment if aynone knows how to do it 
\end{quote}

\begin{quote}
recall to test corner cases (crashes, errors, etc.)
\end{quote}

\subsection{Acceptance test}\label{acceptance-test}

\begin{itemize}
  \item did you perform any \emph{manual} testing?
  %
  \begin{itemize}
    \item what did you test?
    \item why wasn't it automatic? To check response times of server in real time under different real loads on the system. 
  \end{itemize}
\end{itemize}

\section{Deployment}\label{deployment}

\begin{itemize}
  \item should one install your software from scratch, how to do it?
  %
  Docker and docker compose need to be installed. 
  Requirements.txt file stores the python dependencies that can simply be installed with the command pip install -r command. The .yml file spawns a server instance with multiple replicas and a sentinel instance that does failover.
  docker compose up --build 
  command instantiates the containers as specified in the yml file. 
  \begin{itemize}
    \item provide instructions
    \item provide expected outcomes
  \end{itemize}

  \item what software should be installed on the machines to run your project? which versions?
  
  \item should one set environment variables or configuration files?
  Configuration files for the redis master, replica and sentinel are already set up in each game instance so that failover works as intended. 
  \item if you're using containerization (e.g.~Docker), 
  describe how you engineered your deployment scrips (e.g. \texttt{docker-compose.yml} files)
\end{itemize}

\section{User Guide}\label{user-guide}

\begin{itemize}
  \item how to use your software?
  %
  \begin{itemize}
    \item provide instructions
    docker compose up --build
    python client.py in separate terminals for any number of clients 
    \item provide expected outcomes
    spawn a server with the replicas. 
    \item provide screenshots if possible - have some old ones can make new 
  \end{itemize}
\end{itemize}

\section{Self-evaluation}\label{self-evaluation}

\begin{itemize}
  \item An individual section is required for each member of the group
  \item Each member must self-evaluate their work, listing the strengths and weaknesses of the product
  \item Each member must describe their role within the group as objectively as possible.
\end{itemize}

It should be noted that each student is only responsible for their own section.

\section{Future works}\label{future-works}

Discuss possible future works, improvements, extensions, optimizations, etc.

Also discuss here any unimplemented feature, and how you would have implemented it.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
